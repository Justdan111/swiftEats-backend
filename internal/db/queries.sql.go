// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_id, restaurant_id, total_cents, status, idempotency_key)
VALUES ($1,$2,$3,$4,$5)
RETURNING id, user_id, restaurant_id, total_cents, status, idempotency_key, payment_provider, payment_reference, created_at
`

type CreateOrderParams struct {
	UserID         uuid.NullUUID  `json:"user_id"`
	RestaurantID   uuid.NullUUID  `json:"restaurant_id"`
	TotalCents     int32          `json:"total_cents"`
	Status         string         `json:"status"`
	IdempotencyKey sql.NullString `json:"idempotency_key"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.queryRow(ctx, q.createOrderStmt, createOrder,
		arg.UserID,
		arg.RestaurantID,
		arg.TotalCents,
		arg.Status,
		arg.IdempotencyKey,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RestaurantID,
		&i.TotalCents,
		&i.Status,
		&i.IdempotencyKey,
		&i.PaymentProvider,
		&i.PaymentReference,
		&i.CreatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :exec
INSERT INTO order_items (order_id, menu_item_id, quantity, price_cents)
VALUES ($1,$2,$3,$4)
`

type CreateOrderItemParams struct {
	OrderID    uuid.NullUUID `json:"order_id"`
	MenuItemID uuid.NullUUID `json:"menu_item_id"`
	Quantity   int32         `json:"quantity"`
	PriceCents int32         `json:"price_cents"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) error {
	_, err := q.exec(ctx, q.createOrderItemStmt, createOrderItem,
		arg.OrderID,
		arg.MenuItemID,
		arg.Quantity,
		arg.PriceCents,
	)
	return err
}

const findOrderByIdempotency = `-- name: FindOrderByIdempotency :one
SELECT id, user_id, restaurant_id, total_cents, status, idempotency_key, payment_provider, payment_reference, created_at
FROM orders WHERE idempotency_key = $1 LIMIT 1
`

func (q *Queries) FindOrderByIdempotency(ctx context.Context, idempotencyKey sql.NullString) (Order, error) {
	row := q.queryRow(ctx, q.findOrderByIdempotencyStmt, findOrderByIdempotency, idempotencyKey)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RestaurantID,
		&i.TotalCents,
		&i.Status,
		&i.IdempotencyKey,
		&i.PaymentProvider,
		&i.PaymentReference,
		&i.CreatedAt,
	)
	return i, err
}

const getMenuItemByID = `-- name: GetMenuItemByID :one
SELECT id, restaurant_id, category_id, name, description, price_cents, is_available, created_at
FROM menu_items
WHERE id = $1
`

func (q *Queries) GetMenuItemByID(ctx context.Context, id uuid.UUID) (MenuItem, error) {
	row := q.queryRow(ctx, q.getMenuItemByIDStmt, getMenuItemByID, id)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.PriceCents,
		&i.IsAvailable,
		&i.CreatedAt,
	)
	return i, err
}

const getMenuItemsByIDs = `-- name: GetMenuItemsByIDs :many
SELECT id, restaurant_id, category_id, name, description, price_cents, is_available, created_at
FROM menu_items
WHERE id = ANY($1)
`

func (q *Queries) GetMenuItemsByIDs(ctx context.Context, id uuid.UUID) ([]MenuItem, error) {
	rows, err := q.query(ctx, q.getMenuItemsByIDsStmt, getMenuItemsByIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.PriceCents,
			&i.IsAvailable,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, user_id, restaurant_id, total_cents, status, idempotency_key, payment_provider, payment_reference, created_at
FROM orders WHERE id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.queryRow(ctx, q.getOrderByIDStmt, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RestaurantID,
		&i.TotalCents,
		&i.Status,
		&i.IdempotencyKey,
		&i.PaymentProvider,
		&i.PaymentReference,
		&i.CreatedAt,
	)
	return i, err
}

const insertPayment = `-- name: InsertPayment :one
INSERT INTO payments (order_id, provider, provider_reference, amount_cents, status, raw_payload)
VALUES ($1,$2,$3,$4,$5,$6)
RETURNING id, order_id, provider, provider_reference, amount_cents, status, raw_payload, created_at
`

type InsertPaymentParams struct {
	OrderID           uuid.NullUUID         `json:"order_id"`
	Provider          sql.NullString        `json:"provider"`
	ProviderReference sql.NullString        `json:"provider_reference"`
	AmountCents       sql.NullInt32         `json:"amount_cents"`
	Status            sql.NullString        `json:"status"`
	RawPayload        pqtype.NullRawMessage `json:"raw_payload"`
}

func (q *Queries) InsertPayment(ctx context.Context, arg InsertPaymentParams) (Payment, error) {
	row := q.queryRow(ctx, q.insertPaymentStmt, insertPayment,
		arg.OrderID,
		arg.Provider,
		arg.ProviderReference,
		arg.AmountCents,
		arg.Status,
		arg.RawPayload,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.Provider,
		&i.ProviderReference,
		&i.AmountCents,
		&i.Status,
		&i.RawPayload,
		&i.CreatedAt,
	)
	return i, err
}

const updateOrderPaymentAndStatus = `-- name: UpdateOrderPaymentAndStatus :exec
UPDATE orders SET payment_reference = $2, payment_provider = $3, status = $4 WHERE id = $1
`

type UpdateOrderPaymentAndStatusParams struct {
	ID               uuid.UUID      `json:"id"`
	PaymentReference sql.NullString `json:"payment_reference"`
	PaymentProvider  sql.NullString `json:"payment_provider"`
	Status           string         `json:"status"`
}

func (q *Queries) UpdateOrderPaymentAndStatus(ctx context.Context, arg UpdateOrderPaymentAndStatusParams) error {
	_, err := q.exec(ctx, q.updateOrderPaymentAndStatusStmt, updateOrderPaymentAndStatus,
		arg.ID,
		arg.PaymentReference,
		arg.PaymentProvider,
		arg.Status,
	)
	return err
}
